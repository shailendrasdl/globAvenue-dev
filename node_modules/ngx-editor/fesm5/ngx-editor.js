import { __decorate, __param } from 'tslib';
import { ɵɵdefineInjectable, Injectable, Optional, ɵɵinject, ViewChild, Component, forwardRef, ViewEncapsulation, InjectionToken, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Plugin, PluginKey, EditorState } from 'prosemirror-state';
import { DecorationSet, Decoration, EditorView } from 'prosemirror-view';
import { setBlockType, lift, wrapIn, toggleMark } from 'prosemirror-commands';
import { liftListItem, wrapInList, listItem as listItem$1, orderedList as orderedList$2, bulletList as bulletList$2 } from 'prosemirror-schema-list';
import { Schema } from 'prosemirror-model';
import { nodes as nodes$1, marks as marks$1 } from 'prosemirror-schema-basic';

var isMarkActive = function (state, type) {
    var _a = state.selection, from = _a.from, $from = _a.$from, to = _a.to, empty = _a.empty;
    if (empty) {
        return !!type.isInSet(state.storedMarks || $from.marks());
    }
    else {
        return state.doc.rangeHasMark(from, to, type);
    }
};

var findNodeType = function (type, $from) {
    for (var i = $from.depth; i > 0; i--) {
        if ($from.node(i).type === type) {
            return $from.node(i).type;
        }
    }
    return null;
};
var ɵ0 = findNodeType;
var isNodeActive = function (state, type, attrs) {
    if (attrs === void 0) { attrs = {}; }
    var _a = state.selection, $from = _a.$from, to = _a.to;
    var node = findNodeType(type, $from);
    if (!Object.entries(attrs).length || !node) {
        return !!node;
    }
    return to <= $from.end() && $from.parent.hasMarkup(type, attrs);
};

var isListItem = function (type, schema) {
    return (type === schema.nodes.list_item ||
        type === schema.nodes.ordered_list ||
        type === schema.nodes.bullet_list);
};

var toggleBlockType = function (type, toggleType, attrs) {
    if (attrs === void 0) { attrs = {}; }
    return function (state, dispatch) {
        var isActive = isNodeActive(state, type, attrs);
        if (isActive) {
            return setBlockType(toggleType)(state, dispatch);
        }
        return setBlockType(type, attrs)(state, dispatch);
    };
};

var toggleList = function (type, itemType) {
    return function (state, dispatch) {
        var isActive = isNodeActive(state, type);
        if (isActive) {
            return liftListItem(itemType)(state, dispatch);
        }
        return wrapInList(type)(state, dispatch);
    };
};

var toggleWrap = function (type) {
    return function (state, dispatch) {
        var isActive = isNodeActive(state, type);
        if (isActive) {
            return lift(state, dispatch);
        }
        return wrapIn(type)(state, dispatch);
    };
};

/* tslint:disable */
var bold = "\n  <path d=\"M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z\" />\n  <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n";

var italic = "\n  <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n  <path d=\"M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z\" />\n";

var code = "\n<path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n<path d=\"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z\"/>\n";

var orderedList = "\n<path d=\"M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z\"/>\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n";

var bulletList = "\n<path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n<path d=\"M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z\"/>\n";

var quote = "\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z\"/>\n";

// Icons source: https://material.io/
var DEFAULT_ICON_HEIGHT = 20;
var DEFAULT_ICON_WIDTH = 20;
var icons = {
    bold: bold,
    italic: italic,
    code: code,
    ordered_list: orderedList,
    bullet_list: bulletList,
    quote: quote
};
// Helper function to create menu icons
function getIconSvg(name, width, height) {
    if (width === void 0) { width = DEFAULT_ICON_WIDTH; }
    if (height === void 0) { height = DEFAULT_ICON_HEIGHT; }
    var path = icons[name] || '<path></path>';
    return "\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 24 24\"\n    fill=\"black\"\n    height=" + height + "\n    width=" + width + "\n  >\n    " + path + "\n  </svg>\n  ";
}

var flatDeep = function (arr, d) {
    if (d === void 0) { d = 1; }
    return d > 0
        ? arr.reduce(function (acc, val) { return acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val); }, [])
        : arr.slice();
};
var ɵ0$1 = flatDeep;

var menuItemsMeta = {
    bold: {
        key: 'strong',
        i18nKey: 'bold',
        icon: 'bold',
        type: 'mark',
    },
    italic: {
        key: 'em',
        i18nKey: 'italics',
        icon: 'italic',
        type: 'mark',
    },
    code: {
        key: 'code',
        i18nKey: 'code',
        icon: 'code',
        type: 'mark',
    },
    ordered_list: {
        key: 'ordered_list',
        i18nKey: 'ordered_list',
        icon: 'ordered_list',
        type: 'node',
    },
    bullet_list: {
        key: 'bullet_list',
        i18nKey: 'bullet_list',
        icon: 'bullet_list',
        type: 'node',
    },
    h1: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 1,
        },
        type: 'node'
    },
    h2: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 2,
        },
        type: 'node'
    },
    h3: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 3,
        },
        type: 'node'
    },
    h4: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 4,
        },
        type: 'node'
    },
    h5: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 5,
        },
        type: 'node'
    },
    h6: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 6,
        },
        type: 'node'
    },
    blockquote: {
        key: 'blockquote',
        i18nKey: 'blockquote',
        icon: 'quote',
        type: 'node'
    }
};

var SEPERATOR_CLASSNAME = 'NgxEditor__Seperator';
var MENU_ITEM_CLASSNAME = 'NgxEditor__MenuItem';
var ACTIVE_MENU_ITEM_CLASSNAME = MENU_ITEM_CLASSNAME + "--Active";
var DISABLED_CLASSNAME = 'NgxEditor--Disabled';
var DROPDWON_ITEM_CLASSNAME = 'NgxEditor__Dropdown';
var DROPWDOWN_OPEN_CLASSNAME = DROPDWON_ITEM_CLASSNAME + "--Open";
var ACTIVE_DROPDOWN_ITEM_CLASSNAME = DROPDWON_ITEM_CLASSNAME + "--Active";
var SELECTED_DROPDOWN_ITEM_CLASSNAME = DROPDWON_ITEM_CLASSNAME + "--Selected";
var DROPDOWN_ITEMS = new Map();
DROPDOWN_ITEMS.set('heading', ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']);
var DropDownView = /** @class */ (function () {
    function DropDownView(dropdownGroup, dropdownFields, editorView, options) {
        this.updates = [];
        this.dropdownGroup = dropdownGroup;
        this.dropdownFields = dropdownFields;
        this.editorView = editorView;
        this.options = options;
    }
    DropDownView.prototype.getWrapperDom = function () {
        var _this = this;
        var isDropdownOpen = false;
        var dropdown = document.createElement('div');
        var labels = this.options.labels;
        dropdown.classList.add(DROPDWON_ITEM_CLASSNAME);
        var dropdownText = document.createElement('div');
        dropdownText.classList.add(DROPDWON_ITEM_CLASSNAME + "__Text");
        dropdownText.textContent = labels[this.dropdownGroup];
        dropdown.appendChild(dropdownText);
        // create dropdown list
        var dropdownMenu = document.createElement('div');
        dropdownMenu.classList.add(DROPDWON_ITEM_CLASSNAME + "__DropdownMenu");
        var mouseDownHandler = function (e) {
            e.preventDefault();
            if (!dropdown.contains(e.target)) {
                closeDropdown();
            }
        };
        var openDropdown = function (e) {
            var target = e.target;
            if (dropdownMenu.contains(target)) {
                return;
            }
            dropdown.classList.add(DROPWDOWN_OPEN_CLASSNAME);
            isDropdownOpen = true;
            window.addEventListener('mousedown', mouseDownHandler);
        };
        var closeDropdown = function () {
            dropdown.classList.remove(DROPWDOWN_OPEN_CLASSNAME);
            isDropdownOpen = false;
            window.removeEventListener('mousedown', mouseDownHandler);
        };
        dropdown.addEventListener('click', function (e) {
            e.preventDefault();
            if (!isDropdownOpen) {
                openDropdown(e);
            }
            else {
                closeDropdown();
            }
        });
        this.dropdownFields.forEach(function (dropdownItem) {
            var menuItem = menuItemsMeta[dropdownItem];
            var text = labels[menuItem.key];
            if (menuItem.key === 'heading') {
                text += " " + menuItem.attrs.level;
            }
            var spec = {
                classNames: [
                    DROPDWON_ITEM_CLASSNAME + "__Item"
                ],
                textContent: text,
                attrs: {
                    title: text
                },
                activeClass: ACTIVE_DROPDOWN_ITEM_CLASSNAME,
                disabledClass: DISABLED_CLASSNAME
            };
            var menuItemView = new MenuItemView(menuItem, _this.editorView, spec);
            var _a = menuItemView.render(), update = _a.update, dom = _a.dom;
            // remove open class once clicked on dropdown value
            dom.addEventListener('click', function (e) {
                e.preventDefault();
                closeDropdown();
            });
            // wrapper to execute when update is called
            var dropUpdate = function (state) {
                update(state);
                // update the dropdown content heading when a class is selected
                var activeEl = dropdownMenu.getElementsByClassName(ACTIVE_DROPDOWN_ITEM_CLASSNAME);
                if (activeEl.length) {
                    var el = activeEl[0];
                    dropdownText.textContent = el.textContent;
                    dropdown.classList.add(SELECTED_DROPDOWN_ITEM_CLASSNAME);
                }
                else {
                    // restore default value
                    dropdownText.textContent = labels[_this.dropdownGroup];
                    dropdown.classList.remove(SELECTED_DROPDOWN_ITEM_CLASSNAME);
                }
            };
            dropdownMenu.appendChild(dom);
            _this.updates.push(dropUpdate);
        });
        dropdown.appendChild(dropdownMenu);
        return dropdown;
    };
    DropDownView.prototype.render = function () {
        this.dom = this.getWrapperDom();
        return {
            dom: this.dom,
            updates: this.updates
        };
    };
    return DropDownView;
}());
var MenuItemView = /** @class */ (function () {
    function MenuItemView(menuItem, editorView, spec) {
        this.menuItem = menuItem;
        this.editorView = editorView;
        this.spec = spec;
    }
    MenuItemView.prototype.render = function () {
        var _this = this;
        var dom = this.dom = this.getDom();
        var schema = this.editorView.state.schema;
        var command = this.setupCommandListeners().command;
        var _a = this.spec, activeClass = _a.activeClass, disabledClass = _a.disabledClass;
        var update = function (state) {
            var menuItem = _this.menuItem;
            var isActive = false;
            var canExecute = command(_this.editorView.state, null);
            if (menuItem.type === 'mark') {
                var type = schema.marks[menuItem.key];
                isActive = isMarkActive(state, type);
            }
            if (menuItem.type === 'node') {
                var type = schema.nodes[menuItem.key];
                isActive = isNodeActive(state, type, menuItem.attrs);
            }
            dom.classList.toggle(activeClass, isActive);
            dom.classList.toggle(disabledClass, !canExecute);
        };
        return {
            dom: dom,
            update: update
        };
    };
    MenuItemView.prototype.getDom = function () {
        var div = document.createElement('div');
        if (this.spec.classNames) {
            this.spec.classNames.forEach(function (className) {
                div.classList.add(className);
            });
        }
        if (this.spec.attrs) {
            Object.entries(this.spec.attrs).forEach(function (obj) {
                div.setAttribute(obj[0], obj[1]);
            });
        }
        if (this.spec.innerHTML) {
            div.innerHTML = this.spec.innerHTML;
        }
        if (this.spec.textContent) {
            div.innerHTML = this.spec.textContent;
        }
        return div;
    };
    MenuItemView.prototype.setupCommandListeners = function () {
        var _this = this;
        var schema = this.editorView.state.schema;
        var command;
        if (this.menuItem.type === 'mark') {
            command = toggleMark(schema.marks[this.menuItem.key]);
        }
        if (this.menuItem.type === 'node') {
            var type = schema.nodes[this.menuItem.key];
            if (isListItem(type, schema)) {
                command = toggleList(type, schema.nodes.list_item);
            }
            if (type === schema.nodes.heading) {
                command = toggleBlockType(type, schema.nodes.paragraph, { level: this.menuItem.attrs.level });
            }
            if (type === schema.nodes.blockquote) {
                command = toggleWrap(type);
            }
        }
        this.dom.addEventListener('mousedown', function (e) {
            e.preventDefault();
            // don't execute if not left click
            if (e.buttons !== 1) {
                return;
            }
            // execute command
            command(_this.editorView.state, _this.editorView.dispatch);
        });
        return { command: command };
    };
    return MenuItemView;
}());
var getSeperatorDom = function () {
    var div = document.createElement('div');
    div.className = SEPERATOR_CLASSNAME;
    return div;
};
var ɵ0$2 = getSeperatorDom;
var renderMenu = function (options, editorView, menuDom) {
    var updates = [];
    var toolbar = options.toolbar;
    toolbar.forEach(function (group, toolbarIndex) {
        var isLastMenuGroup = toolbar.length - 1 === toolbarIndex;
        group.forEach(function (toolbarItem, menuIndex) {
            var isLastMenuItem = group.length - 1 === menuIndex;
            // render dropdown
            if (typeof toolbarItem === 'object') {
                Object.keys(toolbarItem).forEach(function (dropdownGroup) {
                    if (DROPDOWN_ITEMS.has(dropdownGroup)) {
                        var dropdown = toolbarItem[dropdownGroup];
                        var dropdownView = new DropDownView(dropdownGroup, dropdown, editorView, options);
                        var rendered = dropdownView.render();
                        updates.push(rendered.updates);
                        menuDom.appendChild(rendered.dom);
                    }
                    else {
                        console.warn('Unkown dropdown group:', dropdownGroup);
                    }
                });
            }
            // render Icons
            if (typeof toolbarItem === 'string') {
                var menuItem = menuItemsMeta[toolbarItem];
                var labels = options.labels;
                if (menuItem) {
                    var spec = {
                        classNames: [
                            MENU_ITEM_CLASSNAME,
                            MENU_ITEM_CLASSNAME + "--Icon",
                        ],
                        innerHTML: getIconSvg(menuItem.icon),
                        attrs: {
                            title: labels[menuItem.i18nKey]
                        },
                        activeClass: ACTIVE_MENU_ITEM_CLASSNAME,
                        disabledClass: DISABLED_CLASSNAME
                    };
                    var menuItemView = new MenuItemView(menuItem, editorView, spec);
                    var _a = menuItemView.render(), update = _a.update, dom = _a.dom;
                    menuDom.appendChild(dom);
                    updates.push(update);
                }
            }
            if (typeof toolbarItem === 'function') {
                var _b = toolbarItem(editorView), dom = _b.dom, update = _b.update;
                menuDom.appendChild(dom);
                updates.push(update);
            }
            if (isLastMenuItem && !isLastMenuGroup) {
                var seperatorDom = getSeperatorDom();
                menuDom.appendChild(seperatorDom);
            }
        });
    });
    var combinedUpdates = flatDeep(updates, Infinity);
    return {
        update: function (state) {
            combinedUpdates.forEach(function (update) {
                update(state);
            });
        }
    };
};

var MenuBarView = /** @class */ (function () {
    function MenuBarView(editorView, options) {
        // const menu = getMenu(toolbar);
        this.view = editorView;
        this.options = options;
        this.render();
        this.update();
    }
    MenuBarView.prototype.render = function () {
        var menuDom = document.createElement('div');
        menuDom.className = 'NgxEditor__MenuBar';
        var update = renderMenu(this.options, this.view, menuDom).update;
        this.updateMenuItems = update;
        this.view.dom.parentNode.insertBefore(menuDom, this.view.dom);
    };
    MenuBarView.prototype.update = function () {
        this.updateMenuItems(this.view.state);
    };
    return MenuBarView;
}());

var DEFAULT_TOOLBAR = [
    ['bold', 'italic'],
    ['code', 'blockquote'],
    ['ordered_list', 'bullet_list'],
    [{ heading: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }]
];
var DEFAULT_LABELS = {
    bold: 'Bold',
    italics: 'Italics',
    code: 'Code',
    ordered_list: 'Ordered List',
    bullet_list: 'Bullet List',
    heading: 'Heading',
    blockquote: 'Quote'
};
var DEFAULT_OPTIONS = {
    toolbar: DEFAULT_TOOLBAR,
    labels: DEFAULT_LABELS
};
function menuPlugin(options) {
    return new Plugin({
        key: new PluginKey('menu'),
        view: function (editorView) {
            return new MenuBarView(editorView, options);
        },
    });
}
var menu = function (options) {
    if (options === void 0) { options = DEFAULT_OPTIONS; }
    return menuPlugin(options);
};
var ɵ0$3 = menu;

var DEFAULT_PLACEHOLDER = 'Type Here...';
var PLACEHOLDER_CLASSNAME = 'NgxEditor__Placeholder';
function placeholderPlugin(text) {
    if (text === void 0) { text = DEFAULT_PLACEHOLDER; }
    return new Plugin({
        key: new PluginKey('placeholder'),
        props: {
            decorations: function (state) {
                var doc = state.doc;
                if (doc.childCount === 1 && doc.firstChild.isTextblock && doc.firstChild.content.size === 0) {
                    var placeHolderEl = document.createElement('span');
                    placeHolderEl.classList.add(PLACEHOLDER_CLASSNAME);
                    placeHolderEl.textContent = text;
                    return DecorationSet.create(doc, [Decoration.widget(1, placeHolderEl)]);
                }
                return DecorationSet.empty;
            }
        }
    });
}

var listGroup = 'block';
var listItem = Object.assign({}, listItem$1, { content: 'paragraph block*' });
var orderedList$1 = Object.assign({}, orderedList$2, { content: 'list_item+', group: listGroup });
var bulletList$1 = Object.assign({}, bulletList$2, { content: 'list_item+', group: listGroup });
var nodes = Object.assign({}, nodes$1, {
    list_item: listItem,
    ordered_list: orderedList$1,
    bullet_list: bulletList$1
});
var marks = marks$1;
var schema = new Schema({
    marks: marks,
    nodes: nodes
});

var NgxEditorServiceConfig = /** @class */ (function () {
    function NgxEditorServiceConfig() {
        this.plugins = [
            menu(),
            placeholderPlugin()
        ];
        this.nodeViews = {};
        this.schema = schema;
    }
    NgxEditorServiceConfig.ɵprov = ɵɵdefineInjectable({ factory: function NgxEditorServiceConfig_Factory() { return new NgxEditorServiceConfig(); }, token: NgxEditorServiceConfig, providedIn: "root" });
    NgxEditorServiceConfig = __decorate([
        Injectable({
            providedIn: 'root'
        })
    ], NgxEditorServiceConfig);
    return NgxEditorServiceConfig;
}());
var NgxEditorService = /** @class */ (function () {
    function NgxEditorService(config) {
        this.config = config;
    }
    NgxEditorService.ctorParameters = function () { return [
        { type: NgxEditorServiceConfig, decorators: [{ type: Optional }] }
    ]; };
    NgxEditorService.ɵprov = ɵɵdefineInjectable({ factory: function NgxEditorService_Factory() { return new NgxEditorService(ɵɵinject(NgxEditorServiceConfig, 8)); }, token: NgxEditorService, providedIn: "root" });
    NgxEditorService = __decorate([
        Injectable({
            providedIn: 'root'
        }),
        __param(0, Optional())
    ], NgxEditorService);
    return NgxEditorService;
}());
var defaultConfig = {
    plugins: [],
    nodeViews: {},
    schema: schema
};
function provideMyServiceOptions(config) {
    return Object.assign({}, defaultConfig, config);
}

var NgxEditorComponent = /** @class */ (function () {
    function NgxEditorComponent(ngxEditorService) {
        this.editorInitialized = false;
        this.config = ngxEditorService.config;
    }
    NgxEditorComponent_1 = NgxEditorComponent;
    NgxEditorComponent.prototype.writeValue = function (value) {
        if (!this.editorInitialized) {
            return;
        }
        this.updateContent(value);
    };
    NgxEditorComponent.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    NgxEditorComponent.prototype.registerOnTouched = function () { };
    NgxEditorComponent.prototype.parseDoc = function (contentJson) {
        if (!contentJson) {
            return null;
        }
        var schema = this.config.schema;
        return schema.nodeFromJSON(contentJson);
    };
    NgxEditorComponent.prototype.updateContent = function (value) {
        try {
            var doc = this.parseDoc(value);
            var state = this.view.state;
            // don't emit if both content is same
            if (doc !== null && state.doc.eq(doc)) {
                return;
            }
            var tr = state.tr;
            tr.replaceWith(0, state.doc.content.size, doc);
            this.view.dispatch(tr);
        }
        catch (err) {
            console.error('Unable to update document.', err);
        }
    };
    NgxEditorComponent.prototype.handleTransactions = function (tr) {
        var state = this.view.state.applyTransaction(tr).state;
        this.view.updateState(state);
        if (tr.docChanged && this.onChange) {
            var json = state.doc.toJSON();
            this.onChange(json);
        }
    };
    NgxEditorComponent.prototype.createEditor = function () {
        var _a = this.config, schema = _a.schema, plugins = _a.plugins, nodeViews = _a.nodeViews;
        this.view = new EditorView(this.ngxEditor.nativeElement, {
            state: EditorState.create({
                schema: schema,
                plugins: plugins
            }),
            nodeViews: nodeViews,
            dispatchTransaction: this.handleTransactions.bind(this),
            attributes: {
                class: 'NgxEditor__Content'
            },
        });
        this.editorInitialized = true;
    };
    NgxEditorComponent.prototype.ngOnInit = function () {
        this.createEditor();
    };
    NgxEditorComponent.prototype.ngOnDestroy = function () {
        this.view.destroy();
    };
    var NgxEditorComponent_1;
    NgxEditorComponent.ctorParameters = function () { return [
        { type: NgxEditorService }
    ]; };
    __decorate([
        ViewChild('ngxEditor', { static: true })
    ], NgxEditorComponent.prototype, "ngxEditor", void 0);
    NgxEditorComponent = NgxEditorComponent_1 = __decorate([
        Component({
            selector: 'ngx-editor',
            template: "<div class=\"NgxEditor\" #ngxEditor></div>\n",
            providers: [{
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: forwardRef(function () { return NgxEditorComponent_1; }),
                    multi: true
                }],
            encapsulation: ViewEncapsulation.None,
            styles: [".NgxEditor{background:padding-box #fff;color:#000;border-radius:4px;border:2px solid rgba(0,0,0,.2)}.NgxEditor__MenuBar{display:flex;padding:.2rem;border-bottom:1px solid #ddd;cursor:default;height:1.85rem}.NgxEditor__MenuItem{border-radius:2px;display:flex;align-items:center;justify-content:center}.NgxEditor__MenuItem:hover{background-color:#f1f1f1}.NgxEditor__MenuItem.NgxEditor__MenuItem--Icon{height:1.85rem;width:1.85rem;transition:.3s ease-in-out;margin-right:2px}.NgxEditor__MenuItem.NgxEditor__MenuItem--Text{padding:0 .3rem}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active{background-color:#e8f0fe;color:#1a73e8}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active svg{fill:#1a73e8}.NgxEditor--Disabled{opacity:.5;pointer-events:none}.NgxEditor__Seperator{border-left:1px solid #ccc;margin:0 .3rem}.NgxEditor__Dropdown{min-width:4rem;position:relative;display:flex;align-items:center}.NgxEditor__Dropdown:hover{background-color:#f1f1f1}.NgxEditor__Dropdown .NgxEditor__Dropdown__Text{display:flex;align-items:center;padding:0 .3rem}.NgxEditor__Dropdown .NgxEditor__Dropdown__Text::after{display:inline-block;content:\"\";margin-left:1.5rem;vertical-align:.25rem;border-top:.25rem solid;border-right:.25rem solid transparent;border-bottom:0;border-left:.25rem solid transparent}.NgxEditor__Dropdown .NgxEditor__Dropdown__DropdownMenu{position:absolute;left:0;top:calc(1.85rem + 2px);box-shadow:rgba(60,64,67,.15) 0 2px 6px 2px;border-radius:4px;background-color:#fff;display:none;z-index:10;width:100%}.NgxEditor__Dropdown .NgxEditor__Dropdown__Item{padding:.5rem;white-space:nowrap;color:inherit}.NgxEditor__Dropdown .NgxEditor__Dropdown__Item:hover{background-color:#ececec}.NgxEditor__Dropdown.NgxEditor__Dropdown--Open,.NgxEditor__Dropdown.NgxEditor__Dropdown--Selected{background-color:#e8f0fe}.NgxEditor__Dropdown.NgxEditor__Dropdown--Open .NgxEditor__Dropdown__Text,.NgxEditor__Dropdown.NgxEditor__Dropdown--Selected .NgxEditor__Dropdown__Text{color:#1a73e8}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active{background-color:#f1f1f1}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active:hover{background-color:#e7e7e7}.NgxEditor__Dropdown.NgxEditor__Dropdown--Open .NgxEditor__Dropdown__DropdownMenu{display:block}.NgxEditor__Placeholder{color:#6c757d;opacity:1}.NgxEditor__Content{padding:.5rem;white-space:pre-wrap}.NgxEditor__Content p{margin:0 0 .7rem}.NgxEditor__Content blockquote{padding-left:1rem;border-left:3px solid #ddd;margin-left:0;margin-right:0}.ProseMirror{outline:0}"]
        })
    ], NgxEditorComponent);
    return NgxEditorComponent;
}());

var NGX_EDITOR_CONFIG_TOKEN = new InjectionToken('NgxEditorConfig');
var NgxEditorModule = /** @class */ (function () {
    function NgxEditorModule() {
    }
    NgxEditorModule_1 = NgxEditorModule;
    NgxEditorModule.forRoot = function (config) {
        return {
            ngModule: NgxEditorModule_1,
            providers: [
                {
                    provide: NGX_EDITOR_CONFIG_TOKEN,
                    useValue: config
                },
                {
                    provide: NgxEditorServiceConfig,
                    useFactory: provideMyServiceOptions,
                    deps: [NGX_EDITOR_CONFIG_TOKEN]
                }
            ]
        };
    };
    var NgxEditorModule_1;
    NgxEditorModule = NgxEditorModule_1 = __decorate([
        NgModule({
            declarations: [NgxEditorComponent],
            exports: [NgxEditorComponent],
        })
    ], NgxEditorModule);
    return NgxEditorModule;
}());

/*
 * Public API Surface of ngx-editor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxEditorComponent, NgxEditorModule, isListItem, isMarkActive, isNodeActive, marks, menu, nodes, placeholderPlugin as placeholder, schema, toggleBlockType, toggleList, toggleWrap, ɵ0, NgxEditorServiceConfig as ɵa, NgxEditorService as ɵb, provideMyServiceOptions as ɵc };
//# sourceMappingURL=ngx-editor.js.map
