import { __decorate, __param } from 'tslib';
import { ɵɵdefineInjectable, Injectable, Optional, ɵɵinject, ViewChild, Component, forwardRef, ViewEncapsulation, InjectionToken, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Plugin, PluginKey, EditorState } from 'prosemirror-state';
import { DecorationSet, Decoration, EditorView } from 'prosemirror-view';
import { setBlockType, lift, wrapIn, toggleMark } from 'prosemirror-commands';
import { liftListItem, wrapInList, listItem as listItem$1, orderedList as orderedList$2, bulletList as bulletList$2 } from 'prosemirror-schema-list';
import { Schema } from 'prosemirror-model';
import { nodes as nodes$1, marks as marks$1 } from 'prosemirror-schema-basic';

const isMarkActive = (state, type) => {
    const { from, $from, to, empty } = state.selection;
    if (empty) {
        return !!type.isInSet(state.storedMarks || $from.marks());
    }
    else {
        return state.doc.rangeHasMark(from, to, type);
    }
};

const findNodeType = (type, $from) => {
    for (let i = $from.depth; i > 0; i--) {
        if ($from.node(i).type === type) {
            return $from.node(i).type;
        }
    }
    return null;
};
const ɵ0 = findNodeType;
const isNodeActive = (state, type, attrs = {}) => {
    const { $from, to } = state.selection;
    const node = findNodeType(type, $from);
    if (!Object.entries(attrs).length || !node) {
        return !!node;
    }
    return to <= $from.end() && $from.parent.hasMarkup(type, attrs);
};

const isListItem = (type, schema) => {
    return (type === schema.nodes.list_item ||
        type === schema.nodes.ordered_list ||
        type === schema.nodes.bullet_list);
};

const toggleBlockType = (type, toggleType, attrs = {}) => {
    return (state, dispatch) => {
        const isActive = isNodeActive(state, type, attrs);
        if (isActive) {
            return setBlockType(toggleType)(state, dispatch);
        }
        return setBlockType(type, attrs)(state, dispatch);
    };
};

const toggleList = (type, itemType) => {
    return (state, dispatch) => {
        const isActive = isNodeActive(state, type);
        if (isActive) {
            return liftListItem(itemType)(state, dispatch);
        }
        return wrapInList(type)(state, dispatch);
    };
};

const toggleWrap = (type) => {
    return (state, dispatch) => {
        const isActive = isNodeActive(state, type);
        if (isActive) {
            return lift(state, dispatch);
        }
        return wrapIn(type)(state, dispatch);
    };
};

/* tslint:disable */
var bold = `
  <path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z" />
  <path d="M0 0h24v24H0z" fill="none" />
`;

var italic = `
  <path d="M0 0h24v24H0z" fill="none" />
  <path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z" />
`;

var code = `
<path d="M0 0h24v24H0V0z" fill="none"/>
<path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>
`;

var orderedList = `
<path d="M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z"/>
<path d="M0 0h24v24H0z" fill="none"/>
`;

var bulletList = `
<path d="M0 0h24v24H0V0z" fill="none"/>
<path d="M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z"/>
`;

var quote = `
<path d="M0 0h24v24H0z" fill="none"/><path d="M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z"/>
`;

// Icons source: https://material.io/
const DEFAULT_ICON_HEIGHT = 20;
const DEFAULT_ICON_WIDTH = 20;
const icons = {
    bold,
    italic,
    code,
    ordered_list: orderedList,
    bullet_list: bulletList,
    quote
};
// Helper function to create menu icons
function getIconSvg(name, width = DEFAULT_ICON_WIDTH, height = DEFAULT_ICON_HEIGHT) {
    const path = icons[name] || '<path></path>';
    return `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 24 24"
    fill="black"
    height=${height}
    width=${width}
  >
    ${path}
  </svg>
  `;
}

const flatDeep = (arr, d = 1) => {
    return d > 0
        ? arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), [])
        : arr.slice();
};
const ɵ0$1 = flatDeep;

const menuItemsMeta = {
    bold: {
        key: 'strong',
        i18nKey: 'bold',
        icon: 'bold',
        type: 'mark',
    },
    italic: {
        key: 'em',
        i18nKey: 'italics',
        icon: 'italic',
        type: 'mark',
    },
    code: {
        key: 'code',
        i18nKey: 'code',
        icon: 'code',
        type: 'mark',
    },
    ordered_list: {
        key: 'ordered_list',
        i18nKey: 'ordered_list',
        icon: 'ordered_list',
        type: 'node',
    },
    bullet_list: {
        key: 'bullet_list',
        i18nKey: 'bullet_list',
        icon: 'bullet_list',
        type: 'node',
    },
    h1: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 1,
        },
        type: 'node'
    },
    h2: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 2,
        },
        type: 'node'
    },
    h3: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 3,
        },
        type: 'node'
    },
    h4: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 4,
        },
        type: 'node'
    },
    h5: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 5,
        },
        type: 'node'
    },
    h6: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 6,
        },
        type: 'node'
    },
    blockquote: {
        key: 'blockquote',
        i18nKey: 'blockquote',
        icon: 'quote',
        type: 'node'
    }
};

const SEPERATOR_CLASSNAME = 'NgxEditor__Seperator';
const MENU_ITEM_CLASSNAME = 'NgxEditor__MenuItem';
const ACTIVE_MENU_ITEM_CLASSNAME = `${MENU_ITEM_CLASSNAME}--Active`;
const DISABLED_CLASSNAME = 'NgxEditor--Disabled';
const DROPDWON_ITEM_CLASSNAME = 'NgxEditor__Dropdown';
const DROPWDOWN_OPEN_CLASSNAME = `${DROPDWON_ITEM_CLASSNAME}--Open`;
const ACTIVE_DROPDOWN_ITEM_CLASSNAME = `${DROPDWON_ITEM_CLASSNAME}--Active`;
const SELECTED_DROPDOWN_ITEM_CLASSNAME = `${DROPDWON_ITEM_CLASSNAME}--Selected`;
const DROPDOWN_ITEMS = new Map();
DROPDOWN_ITEMS.set('heading', ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']);
class DropDownView {
    constructor(dropdownGroup, dropdownFields, editorView, options) {
        this.updates = [];
        this.dropdownGroup = dropdownGroup;
        this.dropdownFields = dropdownFields;
        this.editorView = editorView;
        this.options = options;
    }
    getWrapperDom() {
        let isDropdownOpen = false;
        const dropdown = document.createElement('div');
        const labels = this.options.labels;
        dropdown.classList.add(DROPDWON_ITEM_CLASSNAME);
        const dropdownText = document.createElement('div');
        dropdownText.classList.add(`${DROPDWON_ITEM_CLASSNAME}__Text`);
        dropdownText.textContent = labels[this.dropdownGroup];
        dropdown.appendChild(dropdownText);
        // create dropdown list
        const dropdownMenu = document.createElement('div');
        dropdownMenu.classList.add(`${DROPDWON_ITEM_CLASSNAME}__DropdownMenu`);
        const mouseDownHandler = (e) => {
            e.preventDefault();
            if (!dropdown.contains(e.target)) {
                closeDropdown();
            }
        };
        const openDropdown = (e) => {
            const target = e.target;
            if (dropdownMenu.contains(target)) {
                return;
            }
            dropdown.classList.add(DROPWDOWN_OPEN_CLASSNAME);
            isDropdownOpen = true;
            window.addEventListener('mousedown', mouseDownHandler);
        };
        const closeDropdown = () => {
            dropdown.classList.remove(DROPWDOWN_OPEN_CLASSNAME);
            isDropdownOpen = false;
            window.removeEventListener('mousedown', mouseDownHandler);
        };
        dropdown.addEventListener('click', (e) => {
            e.preventDefault();
            if (!isDropdownOpen) {
                openDropdown(e);
            }
            else {
                closeDropdown();
            }
        });
        this.dropdownFields.forEach(dropdownItem => {
            const menuItem = menuItemsMeta[dropdownItem];
            let text = labels[menuItem.key];
            if (menuItem.key === 'heading') {
                text += ` ${menuItem.attrs.level}`;
            }
            const spec = {
                classNames: [
                    `${DROPDWON_ITEM_CLASSNAME}__Item`
                ],
                textContent: text,
                attrs: {
                    title: text
                },
                activeClass: ACTIVE_DROPDOWN_ITEM_CLASSNAME,
                disabledClass: DISABLED_CLASSNAME
            };
            const menuItemView = new MenuItemView(menuItem, this.editorView, spec);
            const { update, dom } = menuItemView.render();
            // remove open class once clicked on dropdown value
            dom.addEventListener('click', (e) => {
                e.preventDefault();
                closeDropdown();
            });
            // wrapper to execute when update is called
            const dropUpdate = (state) => {
                update(state);
                // update the dropdown content heading when a class is selected
                const activeEl = dropdownMenu.getElementsByClassName(ACTIVE_DROPDOWN_ITEM_CLASSNAME);
                if (activeEl.length) {
                    const el = activeEl[0];
                    dropdownText.textContent = el.textContent;
                    dropdown.classList.add(SELECTED_DROPDOWN_ITEM_CLASSNAME);
                }
                else {
                    // restore default value
                    dropdownText.textContent = labels[this.dropdownGroup];
                    dropdown.classList.remove(SELECTED_DROPDOWN_ITEM_CLASSNAME);
                }
            };
            dropdownMenu.appendChild(dom);
            this.updates.push(dropUpdate);
        });
        dropdown.appendChild(dropdownMenu);
        return dropdown;
    }
    render() {
        this.dom = this.getWrapperDom();
        return {
            dom: this.dom,
            updates: this.updates
        };
    }
}
class MenuItemView {
    constructor(menuItem, editorView, spec) {
        this.menuItem = menuItem;
        this.editorView = editorView;
        this.spec = spec;
    }
    render() {
        const dom = this.dom = this.getDom();
        const { schema } = this.editorView.state;
        const { command } = this.setupCommandListeners();
        const { activeClass, disabledClass } = this.spec;
        const update = (state) => {
            const menuItem = this.menuItem;
            let isActive = false;
            const canExecute = command(this.editorView.state, null);
            if (menuItem.type === 'mark') {
                const type = schema.marks[menuItem.key];
                isActive = isMarkActive(state, type);
            }
            if (menuItem.type === 'node') {
                const type = schema.nodes[menuItem.key];
                isActive = isNodeActive(state, type, menuItem.attrs);
            }
            dom.classList.toggle(activeClass, isActive);
            dom.classList.toggle(disabledClass, !canExecute);
        };
        return {
            dom,
            update
        };
    }
    getDom() {
        const div = document.createElement('div');
        if (this.spec.classNames) {
            this.spec.classNames.forEach(className => {
                div.classList.add(className);
            });
        }
        if (this.spec.attrs) {
            Object.entries(this.spec.attrs).forEach(obj => {
                div.setAttribute(obj[0], obj[1]);
            });
        }
        if (this.spec.innerHTML) {
            div.innerHTML = this.spec.innerHTML;
        }
        if (this.spec.textContent) {
            div.innerHTML = this.spec.textContent;
        }
        return div;
    }
    setupCommandListeners() {
        const { schema } = this.editorView.state;
        let command;
        if (this.menuItem.type === 'mark') {
            command = toggleMark(schema.marks[this.menuItem.key]);
        }
        if (this.menuItem.type === 'node') {
            const type = schema.nodes[this.menuItem.key];
            if (isListItem(type, schema)) {
                command = toggleList(type, schema.nodes.list_item);
            }
            if (type === schema.nodes.heading) {
                command = toggleBlockType(type, schema.nodes.paragraph, { level: this.menuItem.attrs.level });
            }
            if (type === schema.nodes.blockquote) {
                command = toggleWrap(type);
            }
        }
        this.dom.addEventListener('mousedown', (e) => {
            e.preventDefault();
            // don't execute if not left click
            if (e.buttons !== 1) {
                return;
            }
            // execute command
            command(this.editorView.state, this.editorView.dispatch);
        });
        return { command };
    }
}
const getSeperatorDom = () => {
    const div = document.createElement('div');
    div.className = SEPERATOR_CLASSNAME;
    return div;
};
const ɵ0$2 = getSeperatorDom;
const renderMenu = (options, editorView, menuDom) => {
    const updates = [];
    const toolbar = options.toolbar;
    toolbar.forEach((group, toolbarIndex) => {
        const isLastMenuGroup = toolbar.length - 1 === toolbarIndex;
        group.forEach((toolbarItem, menuIndex) => {
            const isLastMenuItem = group.length - 1 === menuIndex;
            // render dropdown
            if (typeof toolbarItem === 'object') {
                Object.keys(toolbarItem).forEach((dropdownGroup) => {
                    if (DROPDOWN_ITEMS.has(dropdownGroup)) {
                        const dropdown = toolbarItem[dropdownGroup];
                        const dropdownView = new DropDownView(dropdownGroup, dropdown, editorView, options);
                        const rendered = dropdownView.render();
                        updates.push(rendered.updates);
                        menuDom.appendChild(rendered.dom);
                    }
                    else {
                        console.warn('Unkown dropdown group:', dropdownGroup);
                    }
                });
            }
            // render Icons
            if (typeof toolbarItem === 'string') {
                const menuItem = menuItemsMeta[toolbarItem];
                const labels = options.labels;
                if (menuItem) {
                    const spec = {
                        classNames: [
                            MENU_ITEM_CLASSNAME,
                            `${MENU_ITEM_CLASSNAME}--Icon`,
                        ],
                        innerHTML: getIconSvg(menuItem.icon),
                        attrs: {
                            title: labels[menuItem.i18nKey]
                        },
                        activeClass: ACTIVE_MENU_ITEM_CLASSNAME,
                        disabledClass: DISABLED_CLASSNAME
                    };
                    const menuItemView = new MenuItemView(menuItem, editorView, spec);
                    const { update, dom } = menuItemView.render();
                    menuDom.appendChild(dom);
                    updates.push(update);
                }
            }
            if (typeof toolbarItem === 'function') {
                const { dom, update } = toolbarItem(editorView);
                menuDom.appendChild(dom);
                updates.push(update);
            }
            if (isLastMenuItem && !isLastMenuGroup) {
                const seperatorDom = getSeperatorDom();
                menuDom.appendChild(seperatorDom);
            }
        });
    });
    const combinedUpdates = flatDeep(updates, Infinity);
    return {
        update(state) {
            combinedUpdates.forEach((update) => {
                update(state);
            });
        }
    };
};

class MenuBarView {
    constructor(editorView, options) {
        // const menu = getMenu(toolbar);
        this.view = editorView;
        this.options = options;
        this.render();
        this.update();
    }
    render() {
        const menuDom = document.createElement('div');
        menuDom.className = 'NgxEditor__MenuBar';
        const { update } = renderMenu(this.options, this.view, menuDom);
        this.updateMenuItems = update;
        this.view.dom.parentNode.insertBefore(menuDom, this.view.dom);
    }
    update() {
        this.updateMenuItems(this.view.state);
    }
}

const DEFAULT_TOOLBAR = [
    ['bold', 'italic'],
    ['code', 'blockquote'],
    ['ordered_list', 'bullet_list'],
    [{ heading: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }]
];
const DEFAULT_LABELS = {
    bold: 'Bold',
    italics: 'Italics',
    code: 'Code',
    ordered_list: 'Ordered List',
    bullet_list: 'Bullet List',
    heading: 'Heading',
    blockquote: 'Quote'
};
const DEFAULT_OPTIONS = {
    toolbar: DEFAULT_TOOLBAR,
    labels: DEFAULT_LABELS
};
function menuPlugin(options) {
    return new Plugin({
        key: new PluginKey('menu'),
        view(editorView) {
            return new MenuBarView(editorView, options);
        },
    });
}
const menu = (options = DEFAULT_OPTIONS) => {
    return menuPlugin(options);
};
const ɵ0$3 = menu;

const DEFAULT_PLACEHOLDER = 'Type Here...';
const PLACEHOLDER_CLASSNAME = 'NgxEditor__Placeholder';
function placeholderPlugin(text = DEFAULT_PLACEHOLDER) {
    return new Plugin({
        key: new PluginKey('placeholder'),
        props: {
            decorations(state) {
                const doc = state.doc;
                if (doc.childCount === 1 && doc.firstChild.isTextblock && doc.firstChild.content.size === 0) {
                    const placeHolderEl = document.createElement('span');
                    placeHolderEl.classList.add(PLACEHOLDER_CLASSNAME);
                    placeHolderEl.textContent = text;
                    return DecorationSet.create(doc, [Decoration.widget(1, placeHolderEl)]);
                }
                return DecorationSet.empty;
            }
        }
    });
}

const listGroup = 'block';
const listItem = Object.assign({}, listItem$1, { content: 'paragraph block*' });
const orderedList$1 = Object.assign({}, orderedList$2, { content: 'list_item+', group: listGroup });
const bulletList$1 = Object.assign({}, bulletList$2, { content: 'list_item+', group: listGroup });
const nodes = Object.assign({}, nodes$1, {
    list_item: listItem,
    ordered_list: orderedList$1,
    bullet_list: bulletList$1
});
const marks = marks$1;
const schema = new Schema({
    marks,
    nodes
});

let NgxEditorServiceConfig = class NgxEditorServiceConfig {
    constructor() {
        this.plugins = [
            menu(),
            placeholderPlugin()
        ];
        this.nodeViews = {};
        this.schema = schema;
    }
};
NgxEditorServiceConfig.ɵprov = ɵɵdefineInjectable({ factory: function NgxEditorServiceConfig_Factory() { return new NgxEditorServiceConfig(); }, token: NgxEditorServiceConfig, providedIn: "root" });
NgxEditorServiceConfig = __decorate([
    Injectable({
        providedIn: 'root'
    })
], NgxEditorServiceConfig);
let NgxEditorService = class NgxEditorService {
    constructor(config) {
        this.config = config;
    }
};
NgxEditorService.ctorParameters = () => [
    { type: NgxEditorServiceConfig, decorators: [{ type: Optional }] }
];
NgxEditorService.ɵprov = ɵɵdefineInjectable({ factory: function NgxEditorService_Factory() { return new NgxEditorService(ɵɵinject(NgxEditorServiceConfig, 8)); }, token: NgxEditorService, providedIn: "root" });
NgxEditorService = __decorate([
    Injectable({
        providedIn: 'root'
    }),
    __param(0, Optional())
], NgxEditorService);
const defaultConfig = {
    plugins: [],
    nodeViews: {},
    schema
};
function provideMyServiceOptions(config) {
    return Object.assign({}, defaultConfig, config);
}

var NgxEditorComponent_1;
let NgxEditorComponent = NgxEditorComponent_1 = class NgxEditorComponent {
    constructor(ngxEditorService) {
        this.editorInitialized = false;
        this.config = ngxEditorService.config;
    }
    writeValue(value) {
        if (!this.editorInitialized) {
            return;
        }
        this.updateContent(value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched() { }
    parseDoc(contentJson) {
        if (!contentJson) {
            return null;
        }
        const { schema } = this.config;
        return schema.nodeFromJSON(contentJson);
    }
    updateContent(value) {
        try {
            const doc = this.parseDoc(value);
            const state = this.view.state;
            // don't emit if both content is same
            if (doc !== null && state.doc.eq(doc)) {
                return;
            }
            const tr = state.tr;
            tr.replaceWith(0, state.doc.content.size, doc);
            this.view.dispatch(tr);
        }
        catch (err) {
            console.error('Unable to update document.', err);
        }
    }
    handleTransactions(tr) {
        const { state } = this.view.state.applyTransaction(tr);
        this.view.updateState(state);
        if (tr.docChanged && this.onChange) {
            const json = state.doc.toJSON();
            this.onChange(json);
        }
    }
    createEditor() {
        const { schema, plugins, nodeViews } = this.config;
        this.view = new EditorView(this.ngxEditor.nativeElement, {
            state: EditorState.create({
                schema,
                plugins
            }),
            nodeViews,
            dispatchTransaction: this.handleTransactions.bind(this),
            attributes: {
                class: 'NgxEditor__Content'
            },
        });
        this.editorInitialized = true;
    }
    ngOnInit() {
        this.createEditor();
    }
    ngOnDestroy() {
        this.view.destroy();
    }
};
NgxEditorComponent.ctorParameters = () => [
    { type: NgxEditorService }
];
__decorate([
    ViewChild('ngxEditor', { static: true })
], NgxEditorComponent.prototype, "ngxEditor", void 0);
NgxEditorComponent = NgxEditorComponent_1 = __decorate([
    Component({
        selector: 'ngx-editor',
        template: "<div class=\"NgxEditor\" #ngxEditor></div>\n",
        providers: [{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NgxEditorComponent_1),
                multi: true
            }],
        encapsulation: ViewEncapsulation.None,
        styles: [".NgxEditor{background:padding-box #fff;color:#000;border-radius:4px;border:2px solid rgba(0,0,0,.2)}.NgxEditor__MenuBar{display:flex;padding:.2rem;border-bottom:1px solid #ddd;cursor:default;height:1.85rem}.NgxEditor__MenuItem{border-radius:2px;display:flex;align-items:center;justify-content:center}.NgxEditor__MenuItem:hover{background-color:#f1f1f1}.NgxEditor__MenuItem.NgxEditor__MenuItem--Icon{height:1.85rem;width:1.85rem;transition:.3s ease-in-out;margin-right:2px}.NgxEditor__MenuItem.NgxEditor__MenuItem--Text{padding:0 .3rem}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active{background-color:#e8f0fe;color:#1a73e8}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active svg{fill:#1a73e8}.NgxEditor--Disabled{opacity:.5;pointer-events:none}.NgxEditor__Seperator{border-left:1px solid #ccc;margin:0 .3rem}.NgxEditor__Dropdown{min-width:4rem;position:relative;display:flex;align-items:center}.NgxEditor__Dropdown:hover{background-color:#f1f1f1}.NgxEditor__Dropdown .NgxEditor__Dropdown__Text{display:flex;align-items:center;padding:0 .3rem}.NgxEditor__Dropdown .NgxEditor__Dropdown__Text::after{display:inline-block;content:\"\";margin-left:1.5rem;vertical-align:.25rem;border-top:.25rem solid;border-right:.25rem solid transparent;border-bottom:0;border-left:.25rem solid transparent}.NgxEditor__Dropdown .NgxEditor__Dropdown__DropdownMenu{position:absolute;left:0;top:calc(1.85rem + 2px);box-shadow:rgba(60,64,67,.15) 0 2px 6px 2px;border-radius:4px;background-color:#fff;display:none;z-index:10;width:100%}.NgxEditor__Dropdown .NgxEditor__Dropdown__Item{padding:.5rem;white-space:nowrap;color:inherit}.NgxEditor__Dropdown .NgxEditor__Dropdown__Item:hover{background-color:#ececec}.NgxEditor__Dropdown.NgxEditor__Dropdown--Open,.NgxEditor__Dropdown.NgxEditor__Dropdown--Selected{background-color:#e8f0fe}.NgxEditor__Dropdown.NgxEditor__Dropdown--Open .NgxEditor__Dropdown__Text,.NgxEditor__Dropdown.NgxEditor__Dropdown--Selected .NgxEditor__Dropdown__Text{color:#1a73e8}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active{background-color:#f1f1f1}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active:hover{background-color:#e7e7e7}.NgxEditor__Dropdown.NgxEditor__Dropdown--Open .NgxEditor__Dropdown__DropdownMenu{display:block}.NgxEditor__Placeholder{color:#6c757d;opacity:1}.NgxEditor__Content{padding:.5rem;white-space:pre-wrap}.NgxEditor__Content p{margin:0 0 .7rem}.NgxEditor__Content blockquote{padding-left:1rem;border-left:3px solid #ddd;margin-left:0;margin-right:0}.ProseMirror{outline:0}"]
    })
], NgxEditorComponent);

var NgxEditorModule_1;
const NGX_EDITOR_CONFIG_TOKEN = new InjectionToken('NgxEditorConfig');
let NgxEditorModule = NgxEditorModule_1 = class NgxEditorModule {
    static forRoot(config) {
        return {
            ngModule: NgxEditorModule_1,
            providers: [
                {
                    provide: NGX_EDITOR_CONFIG_TOKEN,
                    useValue: config
                },
                {
                    provide: NgxEditorServiceConfig,
                    useFactory: provideMyServiceOptions,
                    deps: [NGX_EDITOR_CONFIG_TOKEN]
                }
            ]
        };
    }
};
NgxEditorModule = NgxEditorModule_1 = __decorate([
    NgModule({
        declarations: [NgxEditorComponent],
        exports: [NgxEditorComponent],
    })
], NgxEditorModule);

/*
 * Public API Surface of ngx-editor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxEditorComponent, NgxEditorModule, isListItem, isMarkActive, isNodeActive, marks, menu, nodes, placeholderPlugin as placeholder, schema, toggleBlockType, toggleList, toggleWrap, ɵ0, NgxEditorServiceConfig as ɵa, NgxEditorService as ɵb, provideMyServiceOptions as ɵc };
//# sourceMappingURL=ngx-editor.js.map
